<h2 id="4">4. Mapping records to domain objects</h2>

<p>Easy Batch development is POJO-centric and has been designed with the idea that input data records
    should be projected into the object oriented world of Java and not used in their original format.</p>

    <p>It is the <code><em>RecordMapper</em></code> that lets you map input records to your domain objects.
    You can register an implementation of the <code><em>RecordMapper</em></code> interface as follows:</p>

<div class="bs-callout bs-callout-code">
<pre><code class="java">Engine engine = new EngineBuilder()
    <strong>.mapper(new myRecordMapper())</strong>
    .build();</code></pre>
</div>

<div class="bs-callout bs-callout-warning">
    <h5><i class="fa fa-info-circle"></i> Heads up!</h5>
    <p>Registering a record mapper is <strong>optional</strong>. By default, Easy Batch registers a NoOp record mapper that returns the record as is (no mapping logic).</p>
</div>

<h3>4.1 Mapping flat file records</h3>

<p>Easy Batch comes with two implementations of the <code><em>RecordMapper</em></code> interface to map flat file records to your domain objects:</p>
<ul>
    <li><code><em>DelimitedRecordMapper</em></code>: maps delimiter-separated-values to domain objects</li>
    <li><code><em>FixedLengthRecordMapper</em></code>: maps fixed-length records to domain objects</li>
</ul>

<p>These two mappers also convert raw textual data in flat file records to typed data in your domain objects.

    Easy Batch supports all built-in Java primitive and wrapper types.
    If you want to provide a custom type converter, you can implement the <code><em>TypeConverter</em></code> interface and register your implementation using
    <code><em>DelimitedRecordMapper.registerTypeConverter</em></code> and <code><em>FixedLengthRecordMapper.registerTypeConverter</em></code> methods.</p>

<p>To use these two mappers, you need to add the <code><em>easybatch-flatfile</em></code> module to your dependencies:</p>

<div class="bs-callout bs-callout-code">
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.easybatch&lt;/groupId&gt;
    &lt;artifactId&gt;easybatch-flatfile&lt;/artifactId&gt;
    &lt;version&gt;{{ site.version }}&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>

<div class="bs-callout bs-callout-warning">
    <h5><i class="fa fa-info-circle"></i> Heads up!</h5>
    <p>Note that these mappers should be used in conjunction with the <code><em>FlatFileRecordReader</em></code>.</p>
</div>

<h4>4.1.1 Mapping delimiter-separated values</h4>

<p>To register the <code><em>DelimitedRecordMapper</em></code>, use the following snippet:</p>

<div class="bs-callout bs-callout-code">
<pre><code class="java">Engine engine = new EngineBuilder()
    <strong>.mapper(new DelimitedRecordMapper(MyPojoType.class))</strong>
    .build();</code></pre>
</div>

<p>By default, the <code>DelimiterRecordMapper</code> will use the header record to map delimited fields to domain object fields with the same name.
    If you use this convention of configuration, you <em>should not skip</em> the header record with a record filter.</p>

<p>If you want to use a custom mapping strategy, you can specify field names:</p>

<div class="bs-callout bs-callout-code">
<pre><code class="java">RecordMapper&lt;MyPojo&gt; myPojoMapper =
    new DelimitedRecordMapper(MyPojo.class, new String[]{"myPojoField1", "myPojoField2"});</code></pre>
</div>

<p>Field names should be <em>in the same order</em> as they appear in the delimited record.</p>

<p>You can also map only some fields to your domain object. For example: </p>

<div class="bs-callout bs-callout-code">
<pre><code class="java">RecordMapper&lt;MyPojo&gt; myPojoMapper =
    new DelimitedRecordMapper(MyPojo.class, new Integer[]{1, 4, 7});</code></pre>
</div>

<p>With this constructor, the <code><em>DelimitedRecordMapper</em></code> will only map fields 1, 4 and 7 to your domain objects fields.
    Field names will be retrieved from the header record. If you want to use a custom mapping strategy, you can specify field names
    in the third constructor parameter. For example:</p>

<div class="row">
            <div class="col-md-6">
                <div class="bs-callout bs-callout-code">
<pre><code class="java">RecordMapper&lt;MyPojo&gt; myPojoMapper =
    new DelimitedRecordMapper(MyPojoType.class,
    new Integer[]{1, 4, 7},
    new String[]{"id", "name", "description"});</code></pre>
                </div>
                <p>This will apply mapping defined in the following table.</p>
            </div>
            <div class="col-md-6">
                <table class="table table-bordered table-condensed table-striped  ">
                    <thead>
                    <tr>
                        <th>Delimited field index</th>
                        <th>POJO field</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td>1</td>
                        <td class="center-td">id</td>
                    </tr>
                    <tr>
                        <td>4</td>
                        <td class="center-td">name</td>
                    </tr>
                    <tr>
                        <td>7</td>
                        <td class="center-td">description</td>
                    </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <br>
<p>You can also configure the <code><em>DelimitedRecordMapper</em></code> with custom parameters:</p>

<table class="table table-bordered table-condensed table-striped ">
    <thead>
    <tr>
        <th>Parameter</th>
        <th>Required</th>
        <th>Default value</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td>delimiter</td>
        <td class="center-td">false</td>
        <td>","</td>
    </tr>
    <tr>
        <td>qualifier</td>
        <td class="center-td">false</td>
        <td>""</td>
    </tr>
    <tr>
        <td>trimWhitespaces</td>
        <td>false</td>
        <td class="center-td">true</td>
    </tr>
    </tbody>
</table>

<p>For example, to use the <em>pipe</em> character as a delimiter, use the following snippet:</p>

<div class="bs-callout bs-callout-code">
<pre><code class="java">DelimitedRecordMapper&lt;MyPojo&gt; myPojoMapper = new DelimitedRecordMapper&lt;MyPojo&gt;(MyPojo.class);
    myPojoMapper.setDelimiter("|");</code></pre>
</div>

<p>You can use other setters to provide custom parameters.</p>
<p>If a delimited record is not well formed, the <code><em>DelimitedRecordMapper</em></code> throws an exception that causes the record to be ignored by the engine in the following cases:</p>
<ul>
    <li>Fields number is not equal to the expected fields number (missing field, extra field, etc) as specified in the
        <a href="http://www.ietf.org/rfc/rfc4180.txt" target="_blank">CSV RFC (section 2.4).</a></li>
    <li>A field is not enclosed as expected with the data qualifier</li>
</ul>

<h4>4.1.2 Mapping fixed-length records</h4>

<p>To register the <code><em>FixedLengthRecordMapper</em></code>, use the following snippet:</p>

<div class="bs-callout bs-callout-code">
<pre><code class="java">Engine engine = new EngineBuilder()
    .mapper(new FixedLengthRecordMapper(
        MyPojoType.class,
        new int[]{filed1Length, filed2Length},
        new String[]{"filed1Name", "filed2Name"}))
    .build();</code></pre>
</div>

<p>When you create a <code><em>FixedLengthRecordMapper</em></code>, you should specify your domain object type, an array of field lengths and an array of field names <em>in the same order</em> as they appear in the fixed length record.</p>

<p>If a fixed length record is not well formed, the <code><em>FixedLengthRecordMapper</em></code> throws an exception that causes the record to be ignored by the engine.
    A fixed length record is not well formed if its length is not equal to expected record length.</p>

<h3>4.2 Mapping xml records</h3>

<p>Easy Batch comes with a built-in implementation of the <code><em>RecordMapper</em></code> interface named <code><em>XmlRecordMapper</em></code> to map xml records to your domain objects using <a href="https://jaxb.java.net/" target="_blank">JAXB</a>.</p>

<p>To use this mapper, you should annotate your POJO with JAXB annotations to be able to map xml records to instances of your POJO.</p>

<p>First you need to add the <code><em>easybatch-xml</em></code> module to your dependencies:<p>

<div class="bs-callout bs-callout-code">
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.easybatch&lt;/groupId&gt;
    &lt;artifactId&gt;easybatch-xml&lt;/artifactId&gt;
    &lt;version&gt;{{ site.version }}&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>

    <p>Then you can register the <code><em>XmlRecordMapper</em></code> mapper with the <code><em>EngineBuilder</em></code>:</p>

<div class="bs-callout bs-callout-code">
<pre><code class="java">Engine engine = new EngineBuilder()
    <strong>.mapper(new XmlRecordMapper(MyPojoType.class, myXsdFile))</strong>
    .build();</code></pre>
</div>

<p>When you create an <code>XmlRecordMapper</code>, you should specify your domain object type and an xsd file against which the xml record should be validated (if no xsd is specified, no validation will be applied).</p>

<div class="bs-callout bs-callout-warning">
    <h5><i class="fa fa-info-circle"></i> Heads up!</h5>
    <p>The <code>XmlRecordMapper</code> should be used in conjunction with the <code>XmlRecordReader</code>.</p>
    <p>If you want to register a custom JAXB adapter, or listener, etc you can create an instance of the <code>javax.xml.bind.Unmarshaller</code>,
        register your custom components and then use the constructor <code><em>org.easybatch.xml.XmlRecordMapper(javax.xml.bind.Unmarshaller unmarshaller)</em></code>.
</div>

<h3>4.3 Mapping database records</h3>

<p>The <code><em>JdbcRecordMapper</em></code> allows you to map database records to your domain objects.</p>

<p>To use the <code><em>JdbcRecordMapper</em></code>, first you need to add the <code><em>easybatch-jdbc</em></code> module to your dependencies:</p>

        <div class="bs-callout bs-callout-code">
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.easybatch&lt;/groupId&gt;
    &lt;artifactId&gt;easybatch-jdbc&lt;/artifactId&gt;
    &lt;version&gt;{{ site.version }}&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
        </div>

<p>Then you can register it as follows:</p>
<div class="bs-callout bs-callout-code">
<pre><code class="java">Engine engine = new EngineBuilder()
    <strong>.mapper(new JdbcRecordMapper(MyPojoType.class))</strong>
    .build();</code></pre>
</div>

<p>When you create a <code><em>JdbcRecordMapper</em></code>, you should specify your domain object type. Easy Batch will introspect your bean and use the JDBC result set meta-data to map JDBC columns to fields with the same name.</p>

<p>If column names are different from your Pojo field names, you can specify an array of field names <em>in the same order</em> as in the database record:</p>

<div class="bs-callout bs-callout-code">
<pre><code class="java">Engine engine = new EngineBuilder()
    <strong>.mapper(new JdbcRecordMapper(MyPojoType.class, new String[]{"myPojoField1", "myPojoField2"}))</strong>
    .build();</code></pre>
</div>

<p>Easy Batch will then use this array of field names to map data from columns in the same order as in the JDBC record.</p>

<div class="bs-callout bs-callout-warning">
    <h5><i class="fa fa-info-circle"></i> Heads up!</h5>
    <p>The <code><em>JdbcRecordMapper</em></code> should be used in conjunction with the <code><em>JdbcRecordReader</em></code>.</p>
</div>

<nav>
    <ul class="pager">
        <li class="previous"><a href="#filtering" data-toggle="tab"><span aria-hidden="true">&larr;</span> Filtering data</a></li>
        <li class="next"><a href="#validation" data-toggle="tab">Validating data <span aria-hidden="true">&rarr;</span></a></li>
    </ul>
</nav>
