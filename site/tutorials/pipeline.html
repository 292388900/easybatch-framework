---
layout: template
menu : tutorial
title : Unix-like processing pipeline
---

<h2>1. Introduction</h2>

        <p>We all love the power and elegance of the unix pipeline concept.
            In this tutorial, you will see that Easy Batch allows you to bring this power to the java world.
            You will build a unix like data processing pipeline on tweets. Here is our tweets data source:</p>

<div class="bs-callout bs-callout-code">
    <h5>tweets.csv</h5>
<pre><code>1,foo,easy batch rocks #EasyBatch
2,bar,@foo I do confirm :-)
</code></pre>
</div>

        <p>The goal is to implement the equivalent of the following unix command pipeline:</p>

<div class="bs-callout bs-callout-code">
<pre><code>cat tweets.csv | grep '#EasyBatch' | cut -d',' -f3 | wc -w</code></pre>
</div>

        <p>This will count the number of words in tweets containing the hash tag <code>#EasyBatch</code>.</p>

        <p>Let's get your hands dirty!</p>

<h2>2. What youâ€™ll need</h2>

<ul>
    <li>JDK 1.6+</li>
    <li>Maven</li>
    <li>Git (Optional)</li>
    <li>Your favorite IDE (Optional)</li>
</ul>

<h2>3. Reading tweets</h2>

        <p>As in previous tutorial, you can use the <code><em>FlatFileRecordReader</em></code> to read tweets from the <code>tweets.csv</code> file:</p>

<div class="bs-callout bs-callout-code">
<pre><code>Engine engine = new EngineBuilder()
    <strong>.reader(new FlatFileRecordReader(new File("tweets.csv")))</strong>
    .build();</code></pre>
</div>

        <p>This reader will produce <code><em>StringRecord</em></code> with string payloads. You will implement several processor to operate on these strings.</p>

<h2>4. Grepping tweets</h2>

        <p>The <code>RecordFilter</code> API is a perfect candidate to implement the <code>grep</code> command.</p>
        <p>Easy Batch provides a built-in filter that mimics the <code>grep</code> command, it is called <code><em>GrepFilter</em></code>:</p>

<div class="bs-callout bs-callout-code">
<pre><code>Engine engine = new EngineBuilder()
    .reader(new FlatFileRecordReader(new File("tweets.csv")))
    <strong>.filter(new GrepFilter("#EasyBatch"))</strong>
    .build();</code></pre>
</div>

<p>This filter will filter records that do not contain the hash tag #EasyBatch.</p>

<h2>5. Splitting tweets</h2>

<p>The next step is to implement the command <code><em>cut -d',' -f3</em></code>. Here is a processor that does the trick:</p>

<div class="bs-callout bs-callout-code">
    <h5>CutProcessor.java</h5>
<pre><code class="java">public class CutProcessor implements RecordProcessor&lt;StringRecord, String&gt; {

    private String delimiter;

    private int fieldNumber;

    public CutProcessor(String delimiter, int fieldNumber) {
        this.delimiter = delimiter;
        this.fieldNumber = fieldNumber;
    }

    @Override
    public String processRecord(StringRecord record) throws Exception {
        return record.getPayload().split(delimiter)[fieldNumber];
    }

}</code></pre>

</div>

<p>No magic, it splits the input record using the delimiter and returns the desired field.
    Note that error handling is not implemented for simplicity's sake <i class="fa fa-smile-o"></i>.</p>

<div class="bs-callout bs-callout-warning">
    <h5><i class="fa fa-info-circle"></i> Heads up!</h5>
    <p>In this example, the type of output object is different from the type of input object. In fact, the record can be transformed
        several times during its journey in the processing pipeline.</p>
</div>

<h2>6. Counting words</h2>

<p>The next step is to implement the <code><em>wc -w</em></code> command. Here is a processor to do it:</p>

<div class="bs-callout bs-callout-code">
    <h5>WordCountProcessor.java</h5>
<pre><code class="java">public class WordCountProcessor implements ComputationalRecordProcessor&lt;String, String, Integer&gt; {

    private Integer count = 0;

    @Override
    public String processRecord(String record) throws Exception {
        count += record.split(" ").length;
        return record;
    }

    @Override
    public Integer getComputationResult() {
        return count;
    }

}</code></pre>
</div>

<p>Another time, no magic, simply count the number of words in the input string.</p>
        <p>Note that this is a <em>computational</em> processor since it does some computation.
            It should be placed at the end of the pipeline.</p>

<h2>7. Putting it all together</h2>

<p>To launch the tutorial, you can use the following class:<p>

<div class="bs-callout bs-callout-code">
<pre><code class="java">public class Launcher {

    public static void main(String[] args) throws Exception {

        // Input file tweets.csv
        File tweets = new File(args[0]);

        // Build a batch engine
        Engine engine = new EngineBuilder()
            .reader(new FlatFileRecordReader(tweets))
            .filter(new GrepFilter("#EasyBatch"))
            .processor(new CutProcessor(",", 2))
            .processor(new WordCountProcessor())
            .build();

        // Run the batch engine
        Report report = engine.call();

        // Print the batch execution result
        System.out.println("The number of words in tweets containing #EasyBatch = "
                + report.getBatchResult());

    }
}</code></pre>
</div>

<h3>7.1 Run the tutorial from the command line</h3>

<p>To run the tutorial, proceed as follow:</p>
<div class="bs-callout bs-callout-code">
<pre><code>$>git clone https://github.com/benas/easy-batch.git
$>cd easy-batch
$>mvn install
$>cd easybatch-tutorials
$>mvn exec:java -PrunPipelineTutorial
</code></pre>
</div>

        <p>You should see the following output:</p>

<div class="bs-callout bs-callout-code">
<pre><code>INFO: Initializing easy batch engine
INFO: Data source: tweets.csv
INFO: Strict mode: false
INFO: Total records = 3
INFO: easy batch engine is running...
INFO: Record #1 [Record{number=1, payload='id,user,message'}] has been filtered.
INFO: Record #3 [Record{number=3, payload='2,bar,@foo I do confirm :-)'}] has been filtered.
The number of words in tweets containing #EasyBatch = 4
INFO: Shutting down easy batch engine</code></pre>
</div>

<h3>7.2 Run the tutorial from your IDE</h3>

<p>First, you need to checkout the source code of the tutorial available <a href="https://github.com/benas/easy-batch/tree/master/easybatch-tutorials/src/main/java/org/easybatch/tutorials/basic/pipeline" target="_blank">here</a>:</p>

<div class="bs-callout bs-callout-code">
    <pre><code>$>git clone https://github.com/benas/easy-batch.git</code></pre>
</div>

<p>If you do not have git installed, you can download a zip file containing the project's source code from GitHub
    <a href="https://github.com/benas/easy-batch/archive/easybatch-{{ site.version }}.zip">here</a>.</p>

<p>Then, import the <code><em>easybatch-tutorials</em></code> module in you favorite IDE and resolve maven dependencies.</p>

<p>Finally, run the <code><em>org.easybatch.tutorials.basic.pipeline.unixLike.Launcher</em></code> class without any argument.</p>

<h2>8. Summary</h2>

<p>In this tutorial, you have learned how to build a unix like data processing pipeline using Easy Batch.
    This is actually a sort of filter-map-reduce implementation.
    All the power is now in your hands to imagine and build all sorts of pipelines, easily!</p>

<h2>9. What's next?</h2>

<p>That was all for basic tutorials, you can now move on to the next level to see how to build real world enterprise
    batch applications using Easy Batch.</p>

<nav>
    <ul class="pager">
        <li class="previous"><a href="./key-apis.html"><span aria-hidden="true">&larr;</span> Key APIs tutorial</a></li>
        <li class="next"><a href="./loading-data.html">Loading data in a database <span aria-hidden="true">&rarr;</span></a></li>
    </ul>
</nav>